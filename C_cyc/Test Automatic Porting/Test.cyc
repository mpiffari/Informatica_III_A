#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>

#define SENDER 0
#define RECEIVER 1
#define PLACE 2

#define MAX_NAMES_LENGTH 30
#define MAX_PLACES_LENGTH 30

#define MAX_LINE_LENGTH 95
#define MAX_POSTCARDS_IN_FILE 50

#define FILE_PATH "E:/PostcardsSimplified.txt"
#define BY_SENDER 1
#define BY_REC	  2
#define BY_PLACE  3
#define EXIT 	  -1

// Dropped because, if memory cannot be allocated, a null pointer exception
// will be raised when dereferencing the null pointer returned by the memory
// allocation function
//void outofmemory() {
//	printf("Out of memory error!\n");
//	exit(1);
//}

typedef struct postcard {
	char* @fat sender_name;
	char* @fat receiver_name;
	char* @fat place;
} postcard;

/* Destructively converts the given zero-terminated string to lowercase */
int min(int a, int b) { 
	return (a < b) ? a : b;
}

int safe_strncpy(char * @notnull @fat dst, const char * @notnull @fat src, unsigned int n) {
    int m = min(min(numelts(dst), numelts(src))-1, n);
    for (int i = 0; i < m; i++)
        *(dst+i) = *(src+i);
    return m;
}

int safe_strcpy(char * @notnull @fat dst, const char * @notnull @fat src) {
    int n = min(numelts(dst), numelts(src));
    return safe_strncpy(dst, src, n-1);
}

void str2lower(char* @fat @zeroterm str) {
	while (*str) {
		if (*str >= 65 && *str <= 90) { // a-z
			*str += 32;
		}
		str++;
	}
}

/*Divides the given string into tokens, delimited in the original string
* by the given delimiter character.
* Returns an array of tokens (as a parameter) and the number of such
* substrings (as the return value). Delimiters are not part of the tokens;
* tokens may also be empty strings.
* If delimiter is '\0', the whole string is one single token.
*/
char?? tokenize(const char? str, char delimiter) {
	const char? s = str;
	// Counts occurrences of the tokens (= delimiters + 1)
	int tokenCount = 1;
	while (*s) {
		if (*s == delimiter)
			tokenCount++;
		s++;
	}

	// Allocate space for tokens array
	char?? t = (char??) calloc(tokenCount, sizeof(char?));

	s = str;
	const char? p = str;
	tokenCount = 0;

	// Scan the string, storing the start (p) and end (s) of
	// every token, and copying the token into the array
	while (1) {
		while (*s != delimiter && *s != '\0' && *s != '\n') {
			s++;
		}

		// s points to the delimiter right after the current token
		int len = s - p;
		t[tokenCount] = calloc((len + 1), sizeof(char));

		safe_strncpy(t[tokenCount], p, len);
		t[tokenCount][len] = '\0'; // Add null char at the end of tokenCount-esimo token
		tokenCount++;

		// when the end of the string has been reached, end the loop
		if (*s == '\0' || *s == '\n')
			break;

		// otherwise, skip the delimiter
		s++;
		p = s; // now p points to the next token's first char
	}
	
	return t;
}

/*
 * Make postcard.
 * If number of informations it's not enough, return NULL postcard
 */
postcard* make_postcard(char* line) {
	postcard* pc = (postcard*) malloc(sizeof(postcard));
	pc->sender_name = (char*) calloc(MAX_NAMES_LENGTH + 1, sizeof(char));
	pc->receiver_name = (char*) calloc(MAX_NAMES_LENGTH + 1, sizeof(char));
	pc->place = (char*) calloc(MAX_PLACES_LENGTH + 1, sizeof(char));

	char?? tokens = (char??) calloc(strlen(line) + 1, sizeof(char?));
	tokens = tokenize(line, '|');
	int numberOfToken = numelts(tokens);
	

	if(numberOfToken == 3) {
		for (int i = 0; i < numberOfToken; i++) {
			str2lower(tokens[i]);
			switch (i) {
			case SENDER:
				safe_strcpy(pc->sender_name, tokens[i]);
				break;
			case RECEIVER:
				safe_strcpy(pc->receiver_name, tokens[i]);
				break;
			case PLACE:
				safe_strcpy(pc->place, tokens[i]);
				break;
			default:
				break;
			}
		}
		
		return pc;
	} else {
		return NULL;
	}
}

void printPostcard (postcard* p) {
	printf("	----------------\n");
	printf("	from: %s\n", p->sender_name);
	printf("	to: %s\n", p->receiver_name);
	printf("	place: %s\n", p->place);
	printf("	----------------\n");
}


/* Read the file and create a list of postcard object, only if it's present
 * all the needed informations.
 * Returns the number of postcards (as a parameter) and the reference of such
 * postcard (as the return value).
 */
//postcard *@fat readFile(int*‘r *‘r num_of_postcard) {
postcard *@fat readFile() {
	postcard *@fat postcards = (postcard *@fat) malloc(sizeof(postcard) * MAX_POSTCARDS_IN_FILE);

	FILE* filePointer = fopen(FILE_PATH, "r");
	if(filePointer == NULL) {
		printf("Error opening file %s\n", FILE_PATH);
		return postcards;
	} else {
		printf("FILE OPENED %s\n", FILE_PATH);
	}
	
	char line[MAX_LINE_LENGTH + 1];
	char* l = (char*) calloc(MAX_LINE_LENGTH + 1, sizeof(char));
	int index = 0; // From 0 to (MAX_POSTCARDS_IN_FILE - 1)

	while(fgets(line, (MAX_LINE_LENGTH + 1), filePointer)) {
		printf("%s\n", line);
		strcpy(l, line);
		postcard* pc = make_postcard(l);
		printPostcard(pc);
		if(pc != NULL) {
			*(postcards + index) = *pc;
			index = index + 1;
		} else {
			printf("__ERROR ON POSTCARD ___\n");
		}
	}

	fclose(filePointer);
	return postcards;
}

/*
 * Search postcards and return them.
 * If number of informations it's not enough, return NULL postcard
 */
/*postcard* findBy(postcard* postcards, char* str_src, int** nop, int findBy) {
	postcard* res = (postcard*) malloc(sizeof(postcard) * (*(*nop)));
	int* nop_searched = calloc(1, sizeof(int));

	int temp = *(*nop);
	for(int i = 0; i < temp; i++) {
		if(findBy == BY_SENDER &&
				strcmp((postcards+i)->sender_name, str_src) == 0) {

			*(res + *nop_searched) = *(postcards + i);
			*nop_searched = *nop_searched + 1;
		} else if(findBy == BY_REC &&
				strcmp((postcards+i)->receiver_name, str_src) == 0) {

			*(res + *nop_searched) = *(postcards + i);
			*nop_searched = *nop_searched + 1;
		} else if(findBy == BY_PLACE &&
				strcmp((postcards+i)->place, str_src) == 0) {

			*(res + *nop_searched) = *(postcards + i);
			*nop_searched = *nop_searched + 1;
		}
	}

	*nop = nop_searched;
	return res;
}*/

int main(){
	printf("\nSTART\n");
	// Console reading through "fgets" append automaticcaly "null"terminator
	char* @fat @zeroterm command = calloc(MAX_LINE_LENGTH + 1, sizeof(char));
	char* @fat @zeroterm command = calloc(MAX_LINE_LENGTH + 1, sizeof(char));
	
	postcard* @fat postcards = (postcard* @fat) malloc(sizeof(postcard) * MAX_POSTCARDS_IN_FILE);
	postcards = readFile();
	//int nop = numelts(postcards);// Number of postcard
	//printf("Number of postcards = %i\n", nop);

	/*postcard* res = (postcard*) malloc(sizeof(postcard) * MAX_POSTCARDS_IN_FILE);
	printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]"
			"\n- EXIT [-1]\n");
	while (atoi(command) != EXIT) {

		gets(command);
		if(atoi(command) == BY_SENDER) {
			printf("BY SENDER --> ");
			gets(param);
			int** nop_searched = &nop;
			str2lower(param);
			res = findBy(postcards, param, nop_searched, BY_SENDER);
			printf("Postcard search: \n");
			if(*(*nop_searched) == 0) {
				printf("----> No postcard match <----\n");
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			} else {
				for(int i = 0; i < *(*nop_searched); i++) {
					printPostcard((res + i));
				}
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			}
		} else if(atoi(command) == BY_REC) {
			printf("BY REC --> ");
			gets(param);
			int** nop_searched = &nop;
			str2lower(param);
			res = findBy(postcards, param, nop_searched, BY_REC);
			printf("Postcard search: \n");
			if(*(*nop_searched) == 0) {
				printf("----> No postcard match <----\n");
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			} else {
				for(int i = 0; i < *(*nop_searched); i++) {
					printPostcard((res + i));
				}
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			}
		} else if(atoi(command) == BY_PLACE) {
			printf("BY PLACE --> ");
			gets(param);
			int** nop_searched = &nop;
			str2lower(param);
			res = findBy(postcards, param, nop_searched, BY_PLACE);
			printf("Postcard search: \n");
			if(*(*nop_searched) == 0)  {
				printf("----> No postcard match <----\n");
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			} else {
				for(int i = 0; i < *(*nop_searched); i++) {
					printPostcard((res + i));
				}
				printf("FIND POSTCARD BY: \n- SENDER [1]\n- RECEIVER [2]\n- PLACE [3]\n- EXIT [-1]\n");
			}
		} else if(atoi(command) == EXIT) {
			printf("EXIT");
		}
	}


	free(command);*/
	return EXIT_SUCCESS;
}